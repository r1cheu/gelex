#include <gtest/gtest.h>

using namespace arma;
TEST(cal_v, base) {
    arma::dcube ZKZtR(3, 3, 2);
    for (size_t i{}; i < ZKZtR.n_slices; ++i) {
        ZKZtR.slice(i) = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    }
    dvec var = {1, 2};
    dmat v = chenx::optim::cal_v(ZKZtR, var);
    dmat v1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    v1 *= 3;
    ASSERT_TRUE(approx_equal(v, v1, "absdiff", 1e-10));
}

TEST(cal_logL, base) {
    dmat v = eye<dmat>(3, 3);     // Identity matrix
    dmat txvx = eye<dmat>(3, 3);  // Identity matrix
    dmat proj = eye<dmat>(3, 3);  // Identity matrix
    dvec y = {1.0, 2.0, 3.0};     // Vector

    double result = chenx::optim::cal_logL(v, txvx, proj, y);
    double expected = -(0 + 0 + 14);  // log_det of identity is 0, rss is 14

    EXPECT_DOUBLE_EQ(result, expected);
}

TEST(inv_txvxvx, base) {
    dmat vi = eye<dmat>(3, 3);  // Identity matrix
    dmat x = eye<dmat>(3, 3);   // Identity matrix

    auto [txvxvx, vx, txvx] = chenx::optim::inv_txvxvx(vi, x);

    dmat expected_txvxvx = eye<dmat>(3, 3);  // Identity matrix
    dmat expected_vx = eye<dmat>(3, 3);      // Identity matrix
    dmat expected_txvx = eye<dmat>(3, 3);    // Identity matrix

    EXPECT_TRUE(approx_equal(txvxvx, expected_txvxvx, "absdiff", 1e-12));
    EXPECT_TRUE(approx_equal(vx, expected_vx, "absdiff", 1e-12));
    EXPECT_TRUE(approx_equal(txvx, expected_txvx, "absdiff", 1e-12));
}

TEST(cal_proj_matrix, base) {
    dmat v = eye<dmat>(3, 3);  // Identity matrix
    dmat x = eye<dmat>(3, 3);  // Identity matrix

    auto [proj_matrix, txvx, vi] = chenx::optim::cal_proj_matrix(v, x);

    dmat expected_proj_matrix = zeros<dmat>(3, 3);  // Identity - Identity * Identity = Zero matrix
    dmat expected_txvx = eye<dmat>(3, 3);           // Identity matrix
    dmat expected_vi = eye<dmat>(3, 3);             // Identity matrix

    EXPECT_TRUE(approx_equal(proj_matrix, expected_proj_matrix, "absdiff", 1e-12));
    EXPECT_TRUE(approx_equal(txvx, expected_txvx, "absdiff", 1e-12));
    EXPECT_TRUE(approx_equal(vi, expected_vi, "absdiff", 1e-12));
}

TEST(cal_pdv, base) {
    dmat proj = eye<dmat>(3, 3);       // Identity matrix
    dcube zkztr(3, 3, 2, fill::ones);  // Cube filled with ones

    dcube result = chenx::optim::cal_pdv(proj, zkztr);

    dcube expected_result(3, 3, 2, fill::ones);  // Result should be the same as zkztr

    EXPECT_TRUE(approx_equal(result, expected_result, "absdiff", 1e-12));
}

TEST(cal_score, base) {
    dvec y = {1.0, 2.0, 3.0};        // Vector
    dmat proj = eye<dmat>(3, 3);     // Identity matrix
    dcube pdv(3, 3, 2, fill::ones);  // Cube filled with ones

    dvec result = chenx::optim::cal_score(y, proj, pdv);

    dvec expected_result(2);
    expected_result.fill(-0.5 * (3 - 36));  // trace(pdv_i) is 3, yT_pdv_proj_y is 14

    EXPECT_TRUE(approx_equal(result, expected_result, "absdiff", 1e-12));
}

TEST(cal_info_matrix, ai) {
    dvec y = {1.0, 2.0, 3.0};
    dmat proj = eye<dmat>(3, 3);
    dcube pdv(3, 3, 2, fill::ones);

    dmat info_mat = chenx::optim::cal_info_matrix(y, pdv, proj, "AI");
    dmat expected_info_mat(2, 2);
    expected_info_mat.fill(-54);

    EXPECT_TRUE(approx_equal(info_mat, expected_info_mat, "absdiff", 1e-12));
}

TEST(cal_info_matrix, nr) {
    dvec y = {1.0, 2.0, 3.0};
    dmat proj = eye<dmat>(3, 3);
    dcube pdv(3, 3, 2, fill::ones);

    dmat info_mat = chenx::optim::cal_info_matrix(y, pdv, proj, "NR");
    dmat expected_info_mat(2, 2);
    expected_info_mat.fill(4.5 - 108);

    EXPECT_TRUE(approx_equal(info_mat, expected_info_mat, "absdiff", 1e-12));
}

TEST(cal_info_matrix, fisher) {
    dvec y = {1.0, 2.0, 3.0};
    dmat proj = eye<dmat>(3, 3);
    dcube pdv(3, 3, 2, fill::ones);

    dmat info_mat = chenx::optim::cal_info_matrix(y, pdv, proj, "FI");
    dmat expected_info_mat(2, 2);
    expected_info_mat.fill(-4.5);

    EXPECT_TRUE(approx_equal(info_mat, expected_info_mat, "absdiff", 1e-12));
}

TEST(calzkz, base) {
    dmat Z_i = {{1.0, 0.0}, {0.0, 1.0}};
    dmat K_i = {{1.0, 0.0}, {0.0, 1.0}};

    // Test case where both Z_i and K_i are identity matrices
    dmat result = chenx::optim::cal_zkz(Z_i, K_i);
    EXPECT_TRUE(approx_equal(result, K_i, "absdiff", 1e-12));

    // Test case where Z_i is identity and K_i is not identity
    K_i = {{2.0, 0.0}, {0.0, 2.0}};
    result = chenx::optim::cal_zkz(Z_i, K_i);
    EXPECT_TRUE(approx_equal(result, K_i, "absdiff", 1e-12));

    // Test case where Z_i is not identity and K_i is identity
    Z_i = {{1.0, 2.0}, {3.0, 4.0}};
    K_i = {{1.0, 0.0}, {0.0, 1.0}};
    result = chenx::optim::cal_zkz(Z_i, K_i);
    EXPECT_TRUE(approx_equal(result, Z_i * Z_i.t(), "absdiff", 1e-12));

    // Test case where neither Z_i nor K_i are identity matrices
    K_i = {{2.0, 0.0}, {0.0, 2.0}};
    result = chenx::optim::cal_zkz(Z_i, K_i);
    EXPECT_TRUE(approx_equal(result, Z_i * K_i * Z_i.t(), "absdiff", 1e-12));
}

TEST(calzkztr, base) {
    dcube Z(3, 3, 2, fill::ones);
    dcube K(3, 3, 2, fill::ones);

    dcube result = chenx::optim::cal_zkztr(Z, K);

    // Check the dimensions of the result
    EXPECT_EQ(result.n_rows, 3);
    EXPECT_EQ(result.n_cols, 3);
    EXPECT_EQ(result.n_slices, 3);

    // Check the values in the slices
    for (size_t i = 0; i < 2; ++i) {
        dmat expected_slice = Z.slice(i) * K.slice(i) * Z.slice(i).t();
        EXPECT_TRUE(approx_equal(result.slice(i), expected_slice, "absdiff", 1e-6));
    }

    // Check the last slice for identity matrix
    dmat identity = eye(3, 3);
    EXPECT_TRUE(approx_equal(result.slice(2), identity, "absdiff", 1e-6));
}

/*TEST(REML, base) {*/
/*    dmat X(1000, 1, fill::ones);*/
/*    dcube Z(1000, 1000, 2);*/
/*    for (size_t i{}; i < Z.n_slices; ++i) {*/
/*        Z.slice(i) = eye<dmat>(1000, 1000);*/
/*    }*/
/*    dcube rand(1000, 1000, 2);*/
/*    dcolvec vars = {4, 1};*/
/*    for (size_t i{}; i < rand.n_slices; ++i) {*/
/*        dmat temp = randu<dmat>(1000, 1000);*/
/*        rand.slice(i) = temp * temp.t() * vars(i);*/
/*    }*/
/*    dcolvec mean(1000, fill::ones);*/
/*    dcolvec y*/
/*        = X * 1.0 + mvnrnd(mean, rand.slice(0)) + mvnrnd(mean, rand.slice(1)) + mvnrnd(mean, eye<dmat>(1000, 1000));*/
/*    std::string method = "AI";*/
/*    int niter = 10;*/
/*    double tol = 1e-6;*/
/**/
/*    auto [var, beta, vi] = REML(y, X, Z, rand, method, niter, tol);*/
/**/
/*    // Check the results*/
/*    EXPECT_EQ(var.n_elem, rand.n_slices + 1);*/
/*    EXPECT_EQ(beta.n_elem, X.n_cols);*/
/*    EXPECT_EQ(vi.n_rows, X.n_rows);*/
/*    EXPECT_EQ(vi.n_cols, X.n_rows);*/
/*}*/
