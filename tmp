
### 核心设计哲学 (Core Design Philosophy)

1.  **流式处理 (Stream Processing):** `plink bed` 文件可能非常巨大，远超内存容量。核心设计必须是基于“数据流”而非“一次性加载”。`BedPipe` 提供的 `load_chunk` API 完美契合了这一思想。我们的设计将以块（Chunk）为单位进行处理，确保内存占用稳定且可控，这对于高性能计算至关重要。

2.  **关注点分离 (Separation of Concerns):** 计算、数据写入、状态管理是三个不同的关注点。我们将把它们清晰地分离开来。主流程控制类负责编排，统计计算在块内完成，文件写入则由专门的写入器（Writer）类负责。这不仅使代码更清晰、易于维护，也方便进行单元测试。

3.  **零成本抽象 (Zero-Cost Abstraction):** 我们将充分利用现代C++的特性（如 `std::span`, `std::filesystem`）和 Eigen 库的高效性，确保我们构建的抽象层（如写入器类）在编译后不会引入额外的运行时开销。数据将尽可能地“就地” (in-place) 修改，以减少不必要的内存拷贝。

4.  **RAII (Resource Acquisition Is Initialization):** 文件句柄等资源将严格使用RAII模式管理。`std::ofstream` 等标准库设施能够确保即使在发生异常时，资源也能被正确释放，保证程序的健壮性。

### 架构设计 (Architecture Design)

我们将设计一个核心的 `GenotypePipe` 类来编排整个流程。为了实现关注点分离，它将依赖两个辅助的写入器类：`BinaryMatrixWriter` 和 `SnpStatsWriter`。

```
+--------------------------------+
|      GenotypePipe              |
+--------------------------------+
| - BedPipe& bed_pipe_            |
| - std::filesystem::path matrix_path_ |
| - std::filesystem::path stats_path_ |
| - SnpStatisticsAggregator stats_agg_ |
+--------------------------------+
| + process(chunk_size)          |
| # process_chunk(...)           |
+--------------------------------+
        |
        | uses (creates and manages)
        |
+-------+------------------------+-------+
|                                        |
v                                        v
+------------------------+      +--------------------+
|   BinaryMatrixWriter   |      |   SnpStatsWriter   |
+------------------------+      +--------------------+
| - std::ofstream file_  |      | - std::ofstream file_ |
+------------------------+      +--------------------+
| + append_matrix(...)   |      | + write_all(...)   |
+------------------------+      +--------------------+
```

1.  **`GenotypePipe`**: 流程的“大脑”。

      * **职责**:
          * 接收 `BedPipe` 实例和输出文件路径。
          * 按指定的 `chunk_size` 循环调用 `BedPipe::load_chunk`。
          * 对每个加载的块（`Eigen::MatrixXd`）进行标准化处理。
          * 将标准化后的数据块交给 `BinaryMatrixWriter` 写入。
          * 收集每个块的统计信息（均值、标准差、单态SNP索引）。
          * 在所有块处理完毕后，调用 `SnpStatsWriter` 将汇总的统计信息一次性写入文件。

2.  **`BinaryMatrixWriter`**: 基因型矩阵的写入器。

      * **职责**:
          * 在构造时以二进制模式打开基因型矩阵文件。
          * 提供一个 `append_matrix` 方法，接收一个 `const Eigen::MatrixXd&`。此方法将矩阵按列主序（Eigen的默认顺序，完美匹配需求）追加写入到文件中。
          * 利用RAII管理文件句柄。

3.  **`SnpStatsWriter`**: 统计元数据的写入器。

      * **职责**:
          * 在构造时以二进制模式打开统计文件。
          * 提供一个 `write_all` 方法，接收最终的行数、列数、单态SNP数、单态SNP索引向量、均值向量和标准差向量。
          * 按照指定的二进制格式将这些信息写入文件。

4.  **`SnpStatisticsAggregator` (可选但推荐)**: 这是一个状态管理结构体或类。

      * **职责**: 在 `GenotypeMatrixProcessor` 内部使用，用于在处理各个块时，累积存储样本数（仅需一次）、总SNP数、所有SNP的均值、标准差以及单态SNP的全局索引。这使得 `GenotypeMatrixProcessor` 的主逻辑更干净。


### 实现细节与考量 (Implementation Details & Considerations)

1.  **标准化与统计计算**:

      * 对于每个加载的 `Eigen::MatrixXd` 块，我们将逐列（`for (int i = 0; i < chunk.cols(); ++i)`）进行操作。
      * Eigen 提供了非常高效的列操作和向量化计算：`chunk.col(i).mean()` 直接计算均值。计算标准差则可以基于均值和平方的均值 `(chunk.col(i).array().square().mean() - mean*mean).sqrt()`。
      * **性能关键点**: 标准差的计算结果需要检查是否小于 `monomorphic_threshold`。
          * **如果非单态**: 标准化 `chunk.col(i) = (chunk.col(i).array() - mean) / std_dev;`。`array()` 成员函数可以进行元素级的操作。
          * **如果为单态**: 标准化后的列应为全零。直接 `chunk.col(i).setZero();`。同时，为了避免后续使用者除以零，我们应在统计文件中将该SNP的标准差记录为 `1.0`（或一个约定的非零值），并记录其全局索引。
      * 这个计算循环是性能热点，但Eigen的实现已经高度优化（利用SIMD指令集），我们只需确保以正确的方式调用它。

2.  **二进制写入**:

      * `BinaryMatrixWriter::append_matrix`: Eigen 矩阵的数据是连续存储的。可以直接写入：
        `file_.write(reinterpret_cast<const char*>(matrix.data()), matrix.size() * sizeof(double));`
      * `SnpStatsWriter::write_all`: 写入文件头（行数、列数、单态SNP数）时，需要注意字节序，尽管在多数HPC场景下可以假设为小端。写入 `std::vector` 数据时，同样可以直接写入其底层连续数组。
        `file_.write(reinterpret_cast<const char*>(&stats.num_samples), sizeof(stats.num_samples));`
        `file_.write(reinterpret_cast<const char*>(stats.means.data()), stats.means.size() * sizeof(double));`

3.  **C++20 特性应用**:

      * **`std::filesystem::path`**: 如接口所示，用于处理文件路径，比 `std::string` 更健壮、更具表现力。
      * **Ranges**: 虽然此处的列循环非常简单，但如果处理逻辑更复杂，可以考虑使用 `std::views::iota` 和 `std::for_each` 配合lambda表达式来表示，使意图更清晰。
        `std::for_each(std::views::iota(0, chunk.cols()).begin(), ...)`
      * **`std::span`**: 如果 `BinaryMatrixWriter` 或 `SnpStatsWriter` 的接口需要接收不拥有所有权的连续数据视图，`std::span` 将是比 `(const T* data, size_t size)` C-style参数更好的选择。例如，`write_all(const SnpStats&)` 可以改为接收多个 `std::span`。

### 总结 (Conclusion)

这个设计架构兼顾了性能、可扩展性和可维护性：

  * **高性能**: 通过流式块处理，内存占用恒定。直接利用 Eigen 的列主序存储和向量化计算，最大化CPU效率。避免了不必要的数据拷贝。
  * **高内聚、低耦合**: `GenotypeMatrixProcessor` 负责业务逻辑，`Writer` 类负责I/O。职责清晰，易于修改和测试。例如，如果未来需要支持新的输出格式（如HDF5），只需实现一个新的 `Writer` 类，而核心处理逻辑不变。
  * **现代化与健壮性**: 全面采用现代C++特性，如RAII和 `std::filesystem`，确保代码的健壮性和可读性。

这个架构为一个高效、可靠的基因数据处理工具奠定了坚实的基础。下一步就是基于这个设计进行具体的代码实现了。
